#ifndef PXD_TASK_H
#define PXD_TASK_H

#include "px_config.h"

#ifdef __cplusplus
extern "C" 
{
#endif


/*!
\file
Task execution. TODO: OUTDATED!

Task identifiers are generated by various asynchronous operations throughout
the API. Such identifiers can be executed one by one or in groups. The
status of a task or a group of tasks can be either polled or execution
can be blocked until they have finished.

Task identifiers are shared between contexts, so that it is possible 
to execute tasks from several different contexts in one task list.

The order in which tasks are executed is not guaranteed and may be 
be arbitrarily altered by the task scheduler for optimization purposes.

Example using wait mechanism:

\code
//Allocate task
pxTask task = pxBroadPhaseUpdate();

//Execute task
pxTaskExecute(&task, 1);

doOtherStuff();

//Blocking wait for task to finish
pxTaskWait(&task, 1);

//It is now safe to retrieve result
\endcode


Example using polling mechanism:

\code
//Allocate task
pxTask task = pxBroadPhaseUpdate();

//Execute task
pxTaskExecute(&task, 1);

while(pxTaskStatus(&task, 1) != PXD_TASK_FINISHED)
{
	doOtherStuff()
}

//It is now safe to retrieve result
\endcode
*/

/************************************************************************/
/* Task handling                                                        */
/************************************************************************/

typedef PxdHandle PxdTask;
typedef PxdHandle PxdContext;

/*!
Return type for task status queries. See pxTaskStatus function.
*/
typedef enum PxdTaskStatus_
{
	/*!
	The task is queued but not yet executing.
	*/
	PXD_TASK_STATUS_QUEUED,
	/*!
	The task is executing
	*/
	PXD_TASK_STATUS_RUNNING,
	/*!
	The task completed successfully
	*/
	PXD_TASK_STATUS_SUCCESS,
	/*!
	The task completed after recovering from some internal exception 
	(such as a QNaN, buffer fill, or issuing a performance warning)
	*/
	PXD_TASK_STATUS_WARN,
	/*!
	The task was killed before completion (probably as a result of a 
	catastrophically failing task)
	*/
	PXD_TASK_STATUS_ABORTED,
	/*!
	The task failed to complete
	*/
	PXD_TASK_STATUS_FAIL,
	/*!
	The task failed to complete, and no further task should be submitted in this context.
	*/
	PXD_TASK_STATUS_CATASTROPHE
} PxdTaskStatus;


/*!
Wait for a task to complete. The result of a task is not guaranteed to 
become available until this method has returned.

A task is complete when the task status no longer is PXD_TASK_STATUS_QUEUED
or PXD_TASK_STATUS_RUNNING.

\param task
Task identifier
*/
PXD_EXPORT_FUNCTION PxdTaskStatus PxdTaskWait(PxdTask task);

/*!
Wait for any task to complete. Will return as soon as any of the tasks
are considered to be completed.

The result of a task is not guaranteed to become available until this 
method has returned.

A task is complete when the task status no longer is PXD_TASK_STATUS_QUEUED
or PXD_TASK_STATUS_RUNNING.

\param task
Array of task identifiers
\param count
Number of task identifiers
\return
Index (relative to provided array of tasks) of task that has finished
*/
PXD_EXPORT_FUNCTION PxUInt PxdTaskWaitAny(PxdTask* task, PxUInt count);

/*!
Poll status for task. This function will return immediately and can be used for polling. 

\param task
Task identifier
*/
PXD_EXPORT_FUNCTION PxdTaskStatus PxdTaskGetStatus(PxdTask task);

/*!
Release internal data associated with a task.

\param task
Task identifier
*/
PXD_EXPORT_FUNCTION void PxdTaskRelease(PxdTask task);

/************************************************************************/
/* Sub task handling                                                    */
/************************************************************************/

/*!
The type of subtask which we send to the user.
*/
typedef enum PxdSubTaskType_
{
	/*!
	Instructs the user that this is a task of normal priority.
	*/
	PXD_SUBTASK_NORMAL,
	/*!
	Instructs the user to wait for all tasks to complete.
	The task function and data will be NULL.
	*/
	PXD_SUBTASK_WAIT,
	
} PxdSubTaskType;

/*!
Called by the user to execute a task provided by PxdUserSubTask
*/
typedef void (*PxdSubTaskExecuteFunc)(void* subTaskData);

/*!
A user sub task callback can be associated with a context. The callback is called with work items
in the form of a data block and a function pointer to call to execute the task(from a thread of 
the users choosing).
*/
typedef void (*PxdUserSubTaskCallback)(PxdSubTaskType taskType, PxdSubTaskExecuteFunc executeFunc, void* subTaskData, void* userParam);


/*!
Profiling information.

WARNING:
The mapping of the zones is context type specific
*/

/*!
Profile-zone data filled in by the profiling calls
*/
typedef struct PxdProfileZone_
{
	//! Name of the zone
	const char* Name;

	//! Call time (in us)
	PxU32 totalTime;

	//! Static heirarchy info
	PxU32 parentIndex;
} PxdProfileZone;

/*!
Get number of profiling zones
*/
PXD_EXPORT_FUNCTION PxInt PxdProfileGetZoneCount(PxdContext context);

/*!
Fill profiling data in us. Buffer must be big enough to hold PxdProfileGetZoneCount zones.
*/
PXD_EXPORT_FUNCTION void PxdProfileGetZoneData(PxdContext context, PxdProfileZone* zoneData);

#ifdef __cplusplus
}
#endif

#endif
